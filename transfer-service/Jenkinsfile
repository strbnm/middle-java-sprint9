pipeline {
    agent any
    options {
        // This is required if you want to clean before build
        skipDefaultCheckout(true)
    }
    environment {
        MODULE                              = 'transfer-service'
        RELEASE_NAME                        = 'bank-app'

        DOCKER_REGISTRY                     = credentials('DOCKER_REGISTRY')
        NEXUS_REPOSITORY_RELEASES_URL       = 'http://nexus:8081/repository/maven-releases/'
        GITHUB_USERNAME                     = credentials('GITHUB_USERNAME')
        IMAGE_TAG                           = "${env.BUILD_NUMBER}"
        NEXUS_PASSWORD                      = credentials('NEXUS_JENKINS_PASSWORD')
        STUBRUNNER_PASSWORD                 = credentials('NEXUS_JENKINS_PASSWORD')
        STUBRUNNER_USERNAME                 = 'jenkins'

        TEST_REPORT_DIR                     = 'build/reports/tests/test'
        CONTRACT_TEST_REPORT_DIR            = 'build/reports/tests/contractTest'
        JACOCO_HTML                         = 'build/reports/jacoco/test/html'

        DB_NAME                             = 'app_db'
        TRANSFER_DB_USER                    = 'transfer_user'
    }

    stages {
        stage('Set CI Version') {
            steps {
                script {
                    def date = new Date()
                    def formatter = new java.text.SimpleDateFormat("yyyyMMdd-HHmm")
                    def timestamp = formatter.format(date)
                    env.IMAGE_TAG = "${env.BUILD_NUMBER}"
                    env.CI_VERSION = "${env.BUILD_NUMBER}-${timestamp}"
                    echo "CI_VERSION set to ${env.CI_VERSION}"
                }
            }
        }
        stage("Получение исходников") {
            steps {
                cleanWs()
                // We need to explicitly checkout from SCM here
                checkout scm
                sh 'chmod +x ./gradlew'
            }
        }
        stage("Сборка и тест") {
            steps {
                sh './gradlew :$MODULE:clean :$MODULE:build -PnexusUsername=jenkins -PnexusPassword=$NEXUS_PASSWORD'
            }
        }
        stage('Генерация метрик') {
            steps {
                echo "Ключевые метрики сборки:"
                echo "- Длительность: ${currentBuild.durationString}"
                echo "- Автор: ${env.BUILD_USER ?: 'N/A'}"
                echo "- Статус: ${currentBuild.currentResult}"
                echo "- Коммит: ${env.GIT_COMMIT ?: 'N/A'}"
            }
        }
        stage('Публикация отчетов') {
            parallel {
                stage('Отчёт Jacoco в HTML') {
                    steps {
                        catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
                            publishHTML(target: [
                                reportDir: "${env.MODULE}/${env.JACOCO_HTML}",
                                reportFiles: 'index.html',
                                reportName: 'Jacoco Code Coverage',
                                keepAll: true,
                                alwaysLinkToLastBuild: true,
                                allowMissing: true
                            ])
                        }
                    }
                }
                stage('Отчёт по тестам в HTML') {
                    steps {
                        catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
                            publishHTML(target: [
                                reportDir: "${env.MODULE}/${env.TEST_REPORT_DIR}",
                                reportFiles: 'index.html',
                                reportName: 'Unit tests report',
                                keepAll: true,
                                alwaysLinkToLastBuild: true,
                                allowMissing: true
                            ])
                        }
                    }
                }
                stage('Отчёт по контрактным тестам в HTML') {
                    steps {
                        catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
                            publishHTML(target: [
                                reportDir: "${env.MODULE}/${env.CONTRACT_TEST_REPORT_DIR}",
                                reportFiles: 'index.html',
                                reportName: 'Contracts tests report',
                                keepAll: true,
                                alwaysLinkToLastBuild: true,
                                allowMissing: true
                            ])
                        }
                    }
                }
            }
        }

        stage("Сборка обзара Docker") {
            steps {
                sh 'docker build -t $DOCKER_REGISTRY/$MODULE:$IMAGE_TAG --build-arg CI_VERSION=$CI_VERSION $MODULE'
            }
        }
        stage('Пуш в репозиторий') {
            steps {
                withCredentials([string(credentialsId: 'GHCR_TOKEN', variable: 'GHCR_TOKEN')]) {
                    sh """
                    echo \$GHCR_TOKEN | docker login ghcr.io -u ${env.GITHUB_USERNAME} --password-stdin
                    docker push ${env.DOCKER_REGISTRY}/${env.MODULE}:${env.IMAGE_TAG}
                    """
                }
            }
        }
        stage('Создание пространства имен') {
            steps {
                sh 'kubectl get namespace test >/dev/null 2>&1 || kubectl create namespace test'
            }
        }
        stage('Create Secrets for TEST') {
            steps {
                withCredentials([string(credentialsId: 'GHCR_TOKEN', variable: 'GHCR_TOKEN')]) {
                    sh """
                    kubectl create secret docker-registry ghcr-registry \\
                    --docker-server=${DOCKER_REGISTRY} \\
                    --docker-username=${GITHUB_USERNAME} \\
                    --docker-password=${GHCR_TOKEN} \\
                    -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
                withCredentials([string(credentialsId: 'ACCOUNTS_SERVICE_DB_PASSWORD', variable: 'DB_PASSWORD')]) {
                    sh """
                    kubectl create secret generic $RELEASE_NAME-$MODULE-db \\
                      --from-literal=password=${DB_PASSWORD} \\
                      -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
                withCredentials([string(credentialsId: 'NOTIFICATION_CLIENT_SECRET', variable: 'NOTIFICATION_CLIENT_SECRET')]) {
                    sh """
                    kubectl create secret generic $RELEASE_NAME-oauth2-client-secret-notifications \\
                      --from-literal=password=${NOTIFICATION_CLIENT_SECRET} \\
                      -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
                withCredentials([string(credentialsId: 'ACCOUNTS_CLIENT_SECRET', variable: 'ACCOUNTS_CLIENT_SECRET')]) {
                    sh """
                    kubectl create secret generic $RELEASE_NAME-oauth2-client-secret-accounts \\
                      --from-literal=password=${ACCOUNTS_CLIENT_SECRET} \\
                      -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
                withCredentials([string(credentialsId: 'BLOCKER_CLIENT_SECRET', variable: 'BLOCKER_CLIENT_SECRET')]) {
                    sh """
                    kubectl create secret generic $RELEASE_NAME-oauth2-client-secret-blocker \\
                      --from-literal=password=${BLOCKER_CLIENT_SECRET} \\
                      -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
                withCredentials([string(credentialsId: 'EXCHANGE_CLIENT_SECRET', variable: 'EXCHANGE_CLIENT_SECRET')]) {
                    sh """
                    kubectl create secret generic $RELEASE_NAME-oauth2-client-secret-exchange \\
                      --from-literal=password=${EXCHANGE_CLIENT_SECRET} \\
                      -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
                withCredentials([string(credentialsId: 'RABBITMQ_DEFAULT_PASS', variable: 'RABBITMQ_PASS')]) {
                    sh """
                    kubectl create secret generic $RELEASE_NAME-rabbitmq \\
                      --from-literal=password=${RABBITMQ_PASS} \\
                      -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
                withCredentials([string(credentialsId: 'KEYCLOAK_PASS', variable: 'KEYCLOAK_PASS')]) {
                    sh """
                    kubectl create secret generic $RELEASE_NAME-keycloak \\
                      --from-literal=password=${KEYCLOAK_PASS} \\
                      -n test --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
            }
        }
        stage('Установка глобальных переменных') {
            steps {
                dir('bank-app') {
                    sh """
                    echo "Рендерим шаблон c глобальными переменными и устанавливаем/обновляем его в кластере"
                    helm template $RELEASE_NAME . \\
                    -n test \\
                    -s templates/configmap.yaml | kubectl apply -n test -f -
                    """
                }
            }
        }
        stage('Install Keycloak if needed') {
            steps {
                sh """
                # Используется только в учебном проекте!!! Создаем ConfigMap с конфигурацией realm из файла.
                # В реальных проектах должно быть создано отдельно и конфигурация не должна храниться в VCS

                helm list -n test | grep keycloak || \\
                kubectl create configmap my-realm-config --from-file=keycloak/bank-app-realm.json \\
                -n test --dry-run=client -o yaml | kubectl apply -f - && \\
                helm upgrade --install keycloak bank-app/charts/keycloak \\
                  -n test --create-namespace \\
                  --set keycloak.enabled=true \\
                  --set keycloak.auth.adminUser=admin \\
                  --set keycloak.auth.existingSecret=$RELEASE_NAME-keycloak \\
                  --set keycloak.extraVolumes[0].name=realm-config \\
                  --set keycloak.extraVolumes[0].configMap.name=my-realm-config \\
                  --set keycloak.extraVolumeMounts[0].name=realm-config \\
                  --set keycloak.extraVolumeMounts[0].mountPath=/opt/bitnami/keycloak/data/import \\
                  --set keycloak.extraVolumeMounts[0].readOnly=true \\
                  --set keycloak.extraStartupArgs="--import-realm" \\
                  --set keycloak.ingress.enabled=true \\
                  --set keycloak.ingress.ingressClassName=nginx \\
                  --set keycloak.ingress.hostname=keycloak.bankapp.local \\
                  --set keycloak.issuer.url=http://keycloak.bankapp.local/realms/bank-app
                """
            }
        }

        stage('Install RabbitMQ if needed') {
            steps {
                sh """
                helm list -n test | grep rabbitmq || \\
                helm upgrade --install rabbitmq bank-app/charts/rabbitmq \\
                -n test --create-namespace \\
                --set rabbitmq.ingress.enabled=true \\
                --set rabbitmq.ingress.hostname=rabbitmq.bankapp.local \\
                --set rabbitmq.ingress.ingressClassName=nginx \\
                --set rabbitmq.port=5672 \\
                --set rabbitmq.host=rabbitmq.bankapp.local \\
                --set rabbitmq.username=ampq_user \\
                --set rabbitmq.existingPasswordSecret=$RELEASE_NAME-rabbitmq
                """
            }
        }

        stage('Helm Deploy to TEST') {
            steps {
                dir('bank-app') {
                    sh """
                    helm upgrade --install bank-app charts/transfer-service \\
                      --namespace test --create-namespace \\
                      --set image.repository=${DOCKER_REGISTRY}/${MODULE} \\
                      --set image.tag=${IMAGE_TAG} \\
                      --set ingress.enabled=true \\
                      --set ingress.host="transfer-service.test.local" \\
                      --set ingress.pathType="ImplementationSpecific" \\
                      --set accounts-db.auth.existingSecret=$RELEASE_NAME-$MODULE-db \\
                      --set imagePullSecrets[0].name=ghcr-registry
                    """
                }
            }
        }
    }
}
